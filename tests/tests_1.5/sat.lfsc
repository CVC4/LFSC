(declare-type bool ())
(declare tt bool)
(declare ff bool)

(declare-type bvar ())

(declare-type lit ())
(declare pos (-> bvar lit))
(declare neg (-> bvar lit))

(declare-type clause ())
(declare cln clause)
(declare clc (-> lit clause clause))

; constructs for general clauses for R, Q, satlem

(declare concat_cl (-> clause clause clause))
(declare clr (-> lit clause clause))

; code to check resolutions

(program append ((c1 clause) (c2 clause)) clause
  (match c1 (cln c2) ((clc l cs) (clc l (append cs c2)))))

; we use marks as follows:
; -- mark 1 to record if we are supposed to remove a positive occurrence of the bvariable.
; -- mark 2 to record if we are supposed to remove a negative occurrence of the bvariable.
; -- mark 3 if we did indeed remove the bvariable positively
; -- mark 4 if we did indeed remove the bvariable negatively
(program simplify_clause ((c clause)) clause
  (match c
    (cln cln)
    ((clc l c1)
      (match l
        ; Set mark 1 on v if it is not set, to indicate we should remove it.
        ; After processing the rest of the clause, set mark 3 if we were already
        ; supposed to remove v (so if mark 1 was set when we began).  Clear mark3
        ; if we were not supposed to be removing v when we began this call.
        ((pos v)
          (let m (ifmarked v tt (do (markbvar v) ff))
          (let cp (simplify_clause c1)
            (match m
              (tt (do (ifmarked3 v v (type v)) cp))
              (ff (do (ifmarked3 v (markvar3 v) v) (markbvar v) (clc l cp)))))))
        ; the same as the code for tt, but using different marks.
        ((neg v)
          (let m (ifmarked2 v tt (do (markbvar2 v) ff))
          (let cp (simplify_clause c1)
            (match m
              (tt (do (ifmarked4 v v (markbvar4 v)) cp))
              (ff (do (ifmarked4 v (markbvar4 v) v) (markbvar2 v) (clc l cp)))))))))
    ((concat_cl c1 c2) (append (simplify_clause c1) (simplify_clause c2)))
    ((clr l c1)
      (match l
        ; set mark 1 to indicate we should remove v, and fail if
        ; mark 3 is not set after processing the rest of the clause
        ; (we will set mark 3 if we remove a positive occurrence of v).
        ((pos v)
            (let m (ifmarked v tt (do (markbvar v) ff))
            (let m3 (ifmarked3 v (do (markvar3 v) tt) ff)
            (let cp (simplify_clause c1)
              (ifmarked3 v (do (match m3 (tt v) (ff (markvar3 v)))
                                (match m (tt v) (ff (markbvar v))) cp)
                          (fail clause))))))
        ; same as the tt case, but with different marks.
        ((neg v)
            (let m2 (ifmarked2 v tt (do (markbvar2 v) ff))
            (let m4 (ifmarked4 v (do (markbvar4 v) tt) ff)
            (let cp (simplify_clause c1)
              (ifmarked4 v (do (match m4 (tt v) (ff (markbvar4 v)))
                                (match m2 (tt v) (ff (markbvar2 v))) cp)
                          (fail clause))))))
   ))))


; resolution proofs

(declare-type holds (clause))

(declare-rule R (var c1 clause) (var c2 clause) (var n bvar)

  (holds c1)  (holds c2)
;-------------------------------------------------------
  (holds (concat_cl (clr (pos n) c1) (clr (neg n) c2)))
)

(declare-rule Q (var c1 clause) (var c2 clause) (var n bvar)

  (holds c1)  (holds c2)
;-------------------------------------------------------
  (holds (concat_cl (clr (neg n) c1) (clr (pos n) c2)))
)

(declare-rule satlem_simplify
  (var c1 clause) (var c2 clause) (var c3 clause)

  (holds c1)
                            (provided (simplify_clause c1) c2)
  (-> (holds c2) (holds c3))
;----------------------------
  (holds c3)
)

(declare-rule satlem (var c1 clause) (var c2 clause)

  (holds c1)  (-> (holds c1) (holds c2))
;----------------------------------------
  (holds c2)
)
